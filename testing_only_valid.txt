starting...
Number of Files: 22
0
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
             name  population    area
id                                   
1000         Oslo      647676  480.76
1001  Copenhaguen      583348   86.20
1002     Helsinki      626305  715.49
1003    Stockholm      917297  188.00
1004    Reykjavik      121822  273.00
display.chop_threshold : float or None
    if set to a float value, all float values smaller then the given threshold
    will be displayed as exactly 0 by repr and friends.
    [default: None] [currently: None]
display.colheader_justify : 'left'/'right'
    Controls the justification of column headers. used by DataFrameFormatter.
    [default: right] [currently: right]
display.column_space No description available.
    [default: 12] [currently: 12]
display.date_dayfirst : boolean
    When True, prints and parses dates with the day first, eg 20/01/2005
    [default: False] [currently: False]
display.date_yearfirst : boolean
    When True, prints and parses dates with the year first, eg 2005/01/20
    [default: False] [currently: False]
display.encoding : str/unicode
    Defaults to the detected encoding of the console.
    Specifies the encoding to be used for strings returned by to_string,
    these are generally strings meant to be displayed on the console.
    [default: cp1252] [currently: cp1252]
display.expand_frame_repr : boolean
    Whether to print out the full DataFrame repr for wide DataFrames across
    multiple lines, `max_columns` is still respected, but the output will
    wrap-around across multiple "pages" if its width exceeds `display.width`.
    [default: True] [currently: True]
display.float_format : callable
    The callable should accept a floating point number and return
    a string with the desired format of the number. This is used
    in some places like SeriesFormatter.
    See formats.format.EngFormatter for an example.
    [default: None] [currently: None]
display.html.border : int
    A ``border=value`` attribute is inserted in the ``<table>`` tag
    for the DataFrame HTML repr.
    [default: 1] [currently: 1]
display.html.table_schema : boolean
    Whether to publish a Table Schema representation for frontends
    that support it.
    (default: False)
    [default: False] [currently: False]
display.html.use_mathjax : boolean
    When True, Jupyter notebook will process table contents using MathJax,
    rendering mathematical expressions enclosed by the dollar symbol.
    (default: True)
    [default: True] [currently: True]
display.large_repr : 'truncate'/'info'
    For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can
    show a truncated table (the default from 0.13), or switch to the view from
    df.info() (the behaviour in earlier versions of pandas).
    [default: truncate] [currently: truncate]
display.latex.escape : bool
    This specifies if the to_latex method of a Dataframe uses escapes special
    characters.
    Valid values: False,True
    [default: True] [currently: True]
display.latex.longtable :bool
    This specifies if the to_latex method of a Dataframe uses the longtable
    format.
    Valid values: False,True
    [default: False] [currently: False]
display.latex.multicolumn : bool
    This specifies if the to_latex method of a Dataframe uses multicolumns
    to pretty-print MultiIndex columns.
    Valid values: False,True
    [default: True] [currently: True]
display.latex.multicolumn_format : bool
    This specifies if the to_latex method of a Dataframe uses multicolumns
    to pretty-print MultiIndex columns.
    Valid values: False,True
    [default: l] [currently: l]
display.latex.multirow : bool
    This specifies if the to_latex method of a Dataframe uses multirows
    to pretty-print MultiIndex rows.
    Valid values: False,True
    [default: False] [currently: False]
display.latex.repr : boolean
    Whether to produce a latex DataFrame representation for jupyter
    environments that support it.
    (default: False)
    [default: False] [currently: False]
display.max_categories : int
    This sets the maximum number of categories pandas should output when
    printing out a `Categorical` or a Series of dtype "category".
    [default: 8] [currently: 8]
display.max_columns : int
    If max_cols is exceeded, switch to truncate view. Depending on
    `large_repr`, objects are either centrally truncated or printed as
    a summary view. 'None' value means unlimited.

    In case python/IPython is running in a terminal and `large_repr`
    equals 'truncate' this can be set to 0 and pandas will auto-detect
    the width of the terminal and print a truncated object which fits
    the screen width. The IPython notebook, IPython qtconsole, or IDLE
    do not run in a terminal and hence it is not possible to do
    correct auto-detection.
    [default: 20] [currently: 20]
display.max_colwidth : int or None
    The maximum width in characters of a column in the repr of
    a pandas data structure. When the column overflows, a "..."
    placeholder is embedded in the output. A 'None' value means unlimited.
    [default: 50] [currently: 50]
display.max_dir_items : int
    The number of items that will be added to `dir(...)`. 'None' value means
    unlimited. Because dir is cached, changing this option will not immediately
    affect already existing dataframes until a column is deleted or added.

    This is for instance used to suggest columns from a dataframe to tab
    completion.
    [default: 100] [currently: 100]
display.max_info_columns : int
    max_info_columns is used in DataFrame.info method to decide if
    per column information will be printed.
    [default: 100] [currently: 100]
display.max_info_rows : int or None
    df.info() will usually show null-counts for each column.
    For large frames this can be quite slow. max_info_rows and max_info_cols
    limit this null check only to frames with smaller dimensions than
    specified.
    [default: 1690785] [currently: 1690785]
display.max_rows : int
    If max_rows is exceeded, switch to truncate view. Depending on
    `large_repr`, objects are either centrally truncated or printed as
    a summary view. 'None' value means unlimited.

    In case python/IPython is running in a terminal and `large_repr`
    equals 'truncate' this can be set to 0 and pandas will auto-detect
    the height of the terminal and print a truncated object which fits
    the screen height. The IPython notebook, IPython qtconsole, or
    IDLE do not run in a terminal and hence it is not possible to do
    correct auto-detection.
    [default: 60] [currently: 60]
display.max_seq_items : int or None
    When pretty-printing a long sequence, no more then `max_seq_items`
    will be printed. If items are omitted, they will be denoted by the
    addition of "..." to the resulting string.

    If set to None, the number of items to be printed is unlimited.
    [default: 100] [currently: 100]
display.memory_usage : bool, string or None
    This specifies if the memory usage of a DataFrame should be displayed when
    df.info() is called. Valid values True,False,'deep'
    [default: True] [currently: True]
display.min_rows : int
    The numbers of rows to show in a truncated view (when `max_rows` is
    exceeded). Ignored when `max_rows` is set to None or 0. When set to
    None, follows the value of `max_rows`.
    [default: 10] [currently: 10]
display.multi_sparse : boolean
    "sparsify" MultiIndex display (don't display repeated
    elements in outer levels within groups)
    [default: True] [currently: True]
display.notebook_repr_html : boolean
    When True, IPython notebook will use html representation for
    pandas objects (if it is available).
    [default: True] [currently: True]
display.pprint_nest_depth : int
    Controls the number of nested levels to process when pretty-printing
    [default: 3] [currently: 3]
display.precision : int
    Floating point output precision in terms of number of places after the
    decimal, for regular formatting as well as scientific notation. Similar
    to ``precision`` in :meth:`numpy.set_printoptions`.
    [default: 6] [currently: 6]
display.show_dimensions : boolean or 'truncate'
    Whether to print out dimensions at the end of DataFrame repr.
    If 'truncate' is specified, only print out the dimensions if the
    frame is truncated (e.g. not display all rows and/or columns)
    [default: truncate] [currently: truncate]
display.unicode.ambiguous_as_wide : boolean
    Whether to use the Unicode East Asian Width to calculate the display text
    width.
    Enabling this may affect to the performance (default: False)
    [default: False] [currently: False]
display.unicode.east_asian_width : boolean
    Whether to use the Unicode East Asian Width to calculate the display text
    width.
    Enabling this may affect to the performance (default: False)
    [default: False] [currently: False]
display.width : int
    Width of the display in characters. In case python/IPython is running in
    a terminal this can be set to None and pandas will correctly auto-detect
    the width.
    Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a
    terminal and hence it is not possible to correctly detect the width.
    [default: 80] [currently: 80]
(5, 3)
Int64Index([1000, 1001, 1002, 1003, 1004], dtype='int64', name='id')
Index(['name', 'population', 'area'], dtype='object')
Worked Total: 1
0
Resetting...
Worked Total: 2
0
Resetting...
Worked Total: 3
0
max length: 10
Resetting...
does not work -- need to run options
FAIL
0
max length: 30
Resetting...
Worked Total: 4
0
max length: 17
Resetting...
does not work -- need to run options
FAIL
0
max length: 27
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
a1: [ 1  2  3  4  5  6  7  8  9 20]
a2: [11. 12. 13. 14. 15. 16. 17. 18. 19. 20.]
a3: [21. 22. 23. 24. 25. 26. 27. 28. 29. 30.]
[33. 36. 39. 42. 45. 48. 51. 54. 57. 70.]
b:  [[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 20.]
 [11. 12. 13. 14. 15. 16. 17. 18. 19. 20.]
 [21. 22. 23. 24. 25. 26. 27. 28. 29. 30.]]
a_median:  [11. 12. 13. 14. 15. 16. 17. 18. 19. 20.]
[[[ 1  2  3]
  [ 3  4  5]]

 [[ 6  7  8]
  [ 9 10 11]]

 [[11 12 13]
  [13 14 15]]]
[[[11 12 13]
  [13 14 15]]

 [[16 17 18]
  [19 20 21]]

 [[21 22 23]
  [23 24 25]]]
[[[16 17 18]
  [18 19 20]]

 [[21 22 23]
  [24 25 26]]

 [[26 27 28]
  [28 29 30]]]
[[[[ 1  2  3]
   [ 3  4  5]]

  [[ 6  7  8]
   [ 9 10 11]]

  [[11 12 13]
   [13 14 15]]]


 [[[11 12 13]
   [13 14 15]]

  [[16 17 18]
   [19 20 21]]

  [[21 22 23]
   [23 24 25]]]


 [[[16 17 18]
   [18 19 20]]

  [[21 22 23]
   [24 25 26]]

  [[26 27 28]
   [28 29 30]]]]
[[[ 9.33333333 10.33333333 11.33333333]
  [11.33333333 12.33333333 13.33333333]]

 [[14.33333333 15.33333333 16.33333333]
  [17.33333333 18.33333333 19.33333333]]

 [[19.33333333 20.33333333 21.33333333]
  [21.33333333 22.33333333 23.33333333]]]
Worked Total: 5
0
max length: 33
Resetting...
Left X: [1217 1731  516 1681  820 1276  513 1533  620  848 1725 1179 1335 1247
 1043 1114 1000  722 1027 1042]
Left Y: [ 570  718  598 1637  973 1092  740 1494 1085  812 1483 1274  420 1737
  469 1379  693 1170 1616 1655]

Right X: [1456.9867 1969.5041  759.6176 1926.1821 1064.753  1519.3516  757.6263
 1777.9063  866.517  1091.4888 1968.8885 1424.1009 1573.3585 1495.0087
 1283.1323 1360.1544 1241.911   968.6122 1275.2397 1290.4392]
Right Y: [ 607.8704  750.1456  644.2066 1671.8493 1016.4819 1130.3748  786.5686
 1530.2668 1131.0995  854.7812 1516.9759 1313.938   456.133  1777.2005
  508.6913 1419.9465  733.7139 1215.0914 1658.5182 1697.4309]

does not work -- need to run options
FAIL
0
max length: 28
Resetting...
Star 1 answer: yzbqklnj282749 (value: 000002c655df7738246e88f6c1c43eb7)
1000000 no match
2000000 no match
3000000 no match
4000000 no match
5000000 no match
6000000 no match
7000000 no match
8000000 no match
9000000 no match
Star 2 answer: yzbqklnj9962624 (value: 0000004b347bf4b398b3f62ace7cd301)
Worked Total: 6
0
Resetting...
Worked Total: 7
0
max length: 48
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
['a', 'b', [0, 1]]
1
b
['0', '2', '3']
['3', '2', '0']
['0', '2', '3', '6', '5', '4']
['0', '1', '0', '2', '3', '6', '5', '4']
['b', 'c']
1
['1', '2']
['2']
555,444,333
['555', '444', '333']
['333', '444', '555']
['333', '444', '555']
['333', '444', '555']
['333', '444', '555']
['333', '444', '555']
['333', '444', '555']
['111', '444', '555']
['333', '444', '555']
['333', '444', '555']
['333', '444', '555']
[0, 1, 2]
Worked Total: 8
0
Resetting...
[0.00272974 0.33355482 0.66437991 0.995205  ]
[0.16814228 0.49896737 0.82979245]
Worked Total: 9
0
max length: 10
Resetting...
0.619047619047619 -0.03174603174603163 0.6507936507936508
[0.9        2.26666667 2.11111111 0.74444444 0.15555556 1.36666667]
Worked Total: 10
0
Resetting...
Worked Total: 11
0
max length: 19
Resetting...
This is i3.x:  1
1
does not work -- need to run options
This is i3.x:  1
1
FAIL
0
max length: 12
Resetting...
Worked Total: 12
0
max length: 16
Resetting...
does not work -- need to run options
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
This is my Message
This is my Message
detail
This is my Message
This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
detail
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
detail
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
This is my Message
detail
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)
Error: ('This is logging error',)

This is my Message
This is my Message
FAIL
0
max length: 17
Resetting...
Except
does not work -- need to run options
Except
Except
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 27, in <module>
  File "<string>", line 21, in search_ch
NameError: name 'chars' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 20, in <module>
  File "<string>", line 17, in inverse
ZeroDivisionError: division by zero

Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 27, in <module>
  File "<string>", line 21, in search_ch
NameError: name 'chars' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 7, in <module>
  File "<string>", line 4, in inverse
ZeroDivisionError: division by zero

Except
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 27, in <module>
  File "<string>", line 21, in search_ch
NameError: name 'chars' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 7, in <module>
  File "<string>", line 4, in inverse
ZeroDivisionError: division by zero

FAIL
0
max length: 16
Resetting...
hola  a todos
Worked Total: 13
0
max length: 38
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
233168
233168
233168
Worked Total: 14
0
max length: 48
Resetting...
Worked Total: 15
0
Resetting...
HI
Worked Total: 16
0
max length: 10
Resetting...
P(X) = 2 / 4 = 0.5
A       |B       |(A or B)
False   | False  |       0
P(X) = 12 / 13.000 = 0.923077
101000001
0 3 A F
0
4
8
C
Worked Total: 17
0
Resetting...
Worked Total: 18
0
Resetting...
Worked Total: 19
0
Resetting...
Worked Total: 20
0
Resetting...
/
/espace-perso/mon-carnet-de-recettes.aspx
/my-profile/edit
/reloaded/users/logout
/recettes/index/categorie/aperitif-ou-buffet?rcp=0
/recettes/index/categorie/entree?rcp=0
/recettes/index/categorie/plat-principal?rcp=0
/recettes/index/categorie/dessert?rcp=0
/recettes?type=boisson
/cuisine-facile/petits-dejeuners-et-brunchs-tp124705.html
/qu-est-ce-qu-on-mange-ce-soir-sc29.html
/recettes/menu-de-la-semaine.aspx
/mieux-cuisiner/recette-de-saison-tp124490.html
/recettes/selections.aspx
/recettes/index/ingredient
/recettes/top-internautes.aspx
/recettes/recettes-incontournables.aspx
/recettes/nouveautes.aspx
/cuisine-rapide/actus-food-tp123982.html
/cuisine-rapide/tendance-tp121939.html
/mieux-cuisiner/mieux-manger-tp125264.html
/mieux-acheter/shopping-ssc20.html?utm_source=website&utm_medium=shopping_menu&utm_campaign=all_sous_categorie
/sp/bon-plan/toutes-nos-offres.html?utm_source=website&utm_medium=shopping_menu&utm_campaign=promo_sous_categorie
/sp/velux/passion-food.html
/pratique/table-conversion.aspx
/recettes
/recettes/videos-ssc49.html
/trucs-et-astuces/astuces-de-cuisine-tp133284.html
/forum/
https://www.marmiton.org/Prix-Marmiton-2023/prix-marmiton-2023-tp186800.html
https://www.marmiton.org/dossier-noel
https://www.marmiton.org/cuisine-rapide/rapide-tp123527.html
/cuisine-rapide/actus-food-tp123982.html
/mieux-cuisiner/mieux-manger-tp125264.html
https://www.marmiton.org/prix-marmiton-2023/prix-marmiton-2023-tp186800.html
/recettes/recette_le-crumble-aux-pommes-du-chat-qui-tousse_10534.aspx
/recettes/recette_tarte-aux-pommes-a-l-alsacienne_11457.aspx
/recettes/recette_pommes-de-terres-sautees_36392.aspx
/recettes/recette_gateau-aux-pommes-facile_13493.aspx
/recettes/recette_tarte-aux-pommes_18588.aspx
/recettes/recette_soupe-veloutee-de-potimarron-et-pommes-de-terre_41161.aspx
/recettes/recette_amour-de-crumble-aux-pommes_29119.aspx
/recettes/recette_puree-de-pommes-de-terre-maison_28054.aspx
/recettes/recette_tarte-pommes-rapees-citrons_18437.aspx
/recettes/recette_gateau-pommes-noix-et-cannelle_16982.aspx
/recettes/recette_gateau-aux-pommes-moelleux-et-ultra-rapide_17683.aspx
/recettes/recette_beignets-de-pomme-de-mon-papi_51021.aspx
/recettes/recherche.aspx?aqt=pommes&page=2
/recettes/recherche.aspx?aqt=pommes&page=3
/recettes/recherche.aspx?aqt=pommes&page=4
/recettes/recherche.aspx?aqt=pommes&page=5
/recettes/recherche.aspx?aqt=pommes&page=6
/recettes/recherche.aspx?aqt=pommes&page=7
/recettes/recherche.aspx?aqt=pommes&page=8
/recettes/recherche.aspx?aqt=pommes&page=9
/recettes/recherche.aspx?aqt=pommes&page=10
/recettes/recherche.aspx?aqt=pommes&page=20
/recettes/recherche.aspx?aqt=pommes&page=30
/recettes/recherche.aspx?aqt=pommes&page=40
/recettes/recherche.aspx?aqt=pommes&page=50
/recettes/recherche.aspx?aqt=pommes&page=60
/recettes/recherche.aspx?aqt=pommes&page=70
/recettes/recherche.aspx?aqt=pommes&page=80
/recettes/recherche.aspx?aqt=pommes&page=84
/reloaded/newsletter/subscribe
https://fr.pinterest.com/marmiton/
https://www.facebook.com/marmiton
https://www.instagram.com/marmiton_org/
https://www.youtube.com/user/marmitonofficiel
https://assistant.google.com/services/invoke/uid/00000058f69ad4c0
http://m.onelink.me/b78587d4
javascript:showCmpPreferencesPopup()
https://marmiton.welcomekit.co/
https://www.marmiton.org/sp/aide/mentions-legales.html
https://www.marmiton.org/sp/aide/conditions-generales-utilisation.html
https://www.marmiton.org/sp/legal/conditions_generales_abonnement.html
/contact
https://www.marmiton.org/aide/faq-foire-aux-questions-s4005514.html
https://www.marmiton.org/sp/aide/politque-de-protection-des-donnees-personnelles.html
https://www.marmiton.org/sp/aide/faq-protection-des-donnees-personnelles.html#NotDisplayCmp
http://www.1001cocktails.com
Worked Total: 21
0
max length: 10
Resetting...
does not work -- need to run options
FAIL
0
max length: 12
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
Worked Total: 22
0
Resetting...

Python version:  3.8.10 (tags/v3.8.10:3d8993a, May  3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)]
Pandas version:  1.4.1
Today's date: 2023-12-04
Dimensions: (104, 11)

Time
1/28/2016 14:13    2
2/10/2016 11:35    2
1/3/2016 4:43      1
2/3/2016 19:37     1
2/9/2016 10:39     1
Name: Time, dtype: int64

Program
MBA                       46
Undergraduate business    36
Other undergraduate       13
Old Fellow                 2
Wharton UGR                1
Name: Program, dtype: int64

Career
Finance                             34
Technology (Google, Amazon, etc)    26
Consulting                          22
Marketing                            5
Wine Drinking                        2
Name: Career, dtype: int64

Programming
None                                                              52
I have taken one programming course                               32
I have taken many courses and forgotten most of what I learned    12
I have taken many courses and/or have extensive experience         7
Name: Programming, dtype: int64

Stats
I have taken one probability or statistics course                 67
I have taken many courses and forgotten most of what I learned    20
I have taken many courses and/or have extensive experience        14
None                                                               2
Name: Stats, dtype: int64

Media
None                          46
Twitter                       27
Facebook                       6
Twitter, Blog (RSS) reader     5
Blog (RSS) reader              4
Name: Media, dtype: int64

Other
Series([], Name: Other, dtype: int64)

Major
Finance                     36
Analytics or other quant    14
Marketing                    9
Management                   8
Economics                    5
Name: Major, dtype: int64

Data
People Analytics                                                                                           1
Physical data                                                                                              1
Nothing crosses it particularly but I do gather regulatory data for work often and could use some help.    1
Economic data, sports analytics                                                                            1
Mobile data\nImages\nNatural language\nNetworks                                                            1
Name: Data, dtype: int64

Why
To help with my career                         67
I heard it was fun                             20
I lost my mind for a minute                     7
Prof. Backus rocks                              1
I am genuinely interested in this material      1
Name: Why, dtype: int64

Topics
Web scraping                                       22
Multivariate regression                            11
Natural language processing                        10
None, I'd prefer to focus on fundamentals.         10
Web scraping, Maps, Natural language processing     6
Name: Topics, dtype: int64
Worked Total: 23
0
max length: 31
Resetting...
does not work -- need to run options
FAIL
0
max length: 25
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
0 a
Worked Total: 24
0
Resetting...
0 a
Worked Total: 25
0
max length: 252
Resetting...
Please note the area of the polygon given by the ordered coordinates,  [(0, 0), (2, 0), (2, 2), (0, 2)] is:  4.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(2, 1), (2, 2), (3, 2)] is:  0.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(2, 2), (3, 2), (2, 1)] is:  0.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(3, 2), (2, 2), (2, 1)] is:  0.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(0, 0), (3, 4), (0, 4), (3, 0)] is:  0.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(0, 0), (3, 4), (0, 4), (2, 6), (0, 4), (3, 0)] is:  0.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(0, 0), (3, 4), (0, 4), (2, 0), (4, 0), (3, 0)] is:  2.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please enter 3 or more (x,y) coordinates!
Please note the area of the polygon given by the ordered coordinates,  [(2, 1), (3, 4)] is:  0.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(2, 1), (3, 1), (4, 1)] is:  0.0 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(2, 1), (2, 4), (2, 6), (3, 4)] is:  2.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(2, 1), (2, 4), (2, 6), (3, 4), (9, 8)] is:  9.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note the area of the polygon given by the ordered coordinates,  [(0, 14), (2, 0), (2, 3), (0, 2), (9, 5), (8, 7)] is:  49.5 square units according to Green's Theorem Area! Yay! Thank you!


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

Please note that the perimeter of the polygon with the ordered coordinates: [(0, 2), (3, 4), (5, 6)] is:  12.837102637643028 units. Thank you!
Please note that the perimeter of the polygon with the ordered coordinates: [(0, 0), (2, 0), (2, 2), (0, 2)] is:  8.0 units. Thank you!
Please note that the perimeter of the polygon with the ordered coordinates: [(0, 14), (2, 0), (2, 3), (0, 2), (9, 5), (8, 7)] is:  41.73125037197032 units. Thank you!
Worked Total: 26
0
max length: 10
Resetting...
Solution set was not empty.
[3, 5] <class 'list'>
Worked Total: 27
0
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
[1, 't1', 't2', 't3']
[2, 't1', 't2', 't3']
[3, 't1', 't2', 't3']
[4, 't1', 't2', 't3']
[5, 't1', 't2', 't3']
Worked Total: 28
0
max length: 12
Resetting...
does not work -- need to run options
Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on function bar in module matplotlib.pyplot:

bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)
    Make a bar plot.
    
    The bars are positioned at *x* with the given *align*\ment. Their
    dimensions are given by *height* and *width*. The vertical baseline
    is *bottom* (default 0).
    
    Many parameters can take either a single value applying to all bars
    or a sequence of values, one for each bar.
    
    Parameters
    ----------
    x : float or array-like
        The x coordinates of the bars. See also *align* for the
        alignment of the bars to the coordinates.
    
    height : float or array-like
        The height(s) of the bars.
    
    width : float or array-like, default: 0.8
        The width(s) of the bars.
    
    bottom : float or array-like, default: 0
        The y coordinate(s) of the bars bases.
    
    align : {'center', 'edge'}, default: 'center'
        Alignment of the bars to the *x* coordinates:
    
        - 'center': Center the base on the *x* positions.
        - 'edge': Align the left edges of the bars with the *x* positions.
    
        To align the bars on the right edge pass a negative *width* and
        ``align='edge'``.
    
    Returns
    -------
    `.BarContainer`
        Container with all the bars and optionally errorbars.
    
    Other Parameters
    ----------------
    color : color or list of color, optional
        The colors of the bar faces.
    
    edgecolor : color or list of color, optional
        The colors of the bar edges.
    
    linewidth : float or array-like, optional
        Width of the bar edge(s). If 0, don't draw edges.
    
    tick_label : str or list of str, optional
        The tick labels of the bars.
        Default: None (Use default numeric labels.)
    
    xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
        If not *None*, add horizontal / vertical errorbars to the bar tips.
        The values are +/- sizes relative to the data:
    
        - scalar: symmetric +/- values for all bars
        - shape(N,): symmetric +/- values for each bar
        - shape(2, N): Separate - and + values for each bar. First row
          contains the lower errors, the second row contains the upper
          errors.
        - *None*: No errorbar. (Default)
    
        See :doc:`/gallery/statistics/errorbar_features`
        for an example on the usage of ``xerr`` and ``yerr``.
    
    ecolor : color or list of color, default: 'black'
        The line color of the errorbars.
    
    capsize : float, default: :rc:`errorbar.capsize`
       The length of the error bar caps in points.
    
    error_kw : dict, optional
        Dictionary of kwargs to be passed to the `~.Axes.errorbar`
        method. Values of *ecolor* or *capsize* defined here take
        precedence over the independent kwargs.
    
    log : bool, default: False
        If *True*, set the y-axis to be log scale.
    
    data : indexable object, optional
        If given, all parameters also accept a string ``s``, which is
        interpreted as ``data[s]`` (unless this raises an exception).
    
    **kwargs : `.Rectangle` properties
    
    Properties:
        agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
        alpha: scalar or None
        angle: unknown
        animated: bool
        antialiased or aa: bool or None
        bounds: (left, bottom, width, height)
        capstyle: `.CapStyle` or {'butt', 'projecting', 'round'}
        clip_box: `.Bbox`
        clip_on: bool
        clip_path: Patch or (Path, Transform) or None
        color: color
        edgecolor or ec: color or None
        facecolor or fc: color or None
        figure: `.Figure`
        fill: bool
        gid: str
        hatch: {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
        height: unknown
        in_layout: bool
        joinstyle: `.JoinStyle` or {'miter', 'round', 'bevel'}
        label: object
        linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
        linewidth or lw: float or None
        path_effects: `.AbstractPathEffect`
        picker: None or bool or float or callable
        rasterized: bool
        sketch_params: (scale: float, length: float, randomness: float)
        snap: bool or None
        transform: `.Transform`
        url: str
        visible: bool
        width: unknown
        x: unknown
        xy: (float, float)
        y: unknown
        zorder: float
    
    See Also
    --------
    barh : Plot a horizontal bar plot.
    
    Notes
    -----
    Stacked bars can be achieved by passing individual *bottom* values per
    bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.

Help on module matplotlib.colors in matplotlib:

NAME
    matplotlib.colors - A module for converting numbers or color arguments to *RGB* or *RGBA*.

DESCRIPTION
    *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the
    range 0-1.
    
    This module includes functions and classes for color specification conversions,
    and for mapping numbers to colors in a 1-D array of colors called a colormap.
    
    Mapping data onto colors using a colormap typically involves two steps: a data
    array is first mapped onto the range 0-1 using a subclass of `Normalize`,
    then this number is mapped to a color using a subclass of `Colormap`.  Two
    subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses
    piecewise-linear interpolation to define colormaps, and `ListedColormap`, which
    makes a colormap from a list of colors.
    
    .. seealso::
    
      :doc:`/tutorials/colors/colormap-manipulation` for examples of how to
      make colormaps and
    
      :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.
    
      :doc:`/tutorials/colors/colormapnorms` for more details about data
      normalization
    
      More colormaps are available at palettable_.
    
    The module also provides functions for checking whether an object can be
    interpreted as a color (`is_color_like`), for converting such an object
    to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the
    "#rrggbb" format (`to_hex`), and a sequence of colors to an (n, 4)
    RGBA array (`to_rgba_array`).  Caching is used for efficiency.
    
    Colors that Matplotlib recognizes are listed at
    :doc:`/tutorials/colors/colors`.
    
    .. _palettable: https://jiffyclub.github.io/palettable/
    .. _xkcd color survey: https://xkcd.com/color/rgb/

CLASSES
    builtins.object
        ColorConverter
        Colormap
            LinearSegmentedColormap
            ListedColormap
        LightSource
        Normalize
            BoundaryNorm
            CenteredNorm
            NoNorm
            PowerNorm
            TwoSlopeNorm
    FuncNorm(Normalize)
        FuncNorm
    LogNorm(Normalize)
        LogNorm
    SymLogNorm(Normalize)
        SymLogNorm
    
    class BoundaryNorm(Normalize)
     |  BoundaryNorm(boundaries, ncolors, clip=False, *, extend='neither')
     |  
     |  Generate a colormap index based on discrete intervals.
     |  
     |  Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers
     |  instead of to the interval 0-1.
     |  
     |  Mapping to the 0-1 interval could have been done via piece-wise linear
     |  interpolation, but using integers seems simpler, and reduces the number of
     |  conversions back and forth between integer and floating point.
     |  
     |  Method resolution order:
     |      BoundaryNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, boundaries, ncolors, clip=False, *, extend='neither')
     |      Parameters
     |      ----------
     |      boundaries : array-like
     |          Monotonically increasing sequence of at least 2 boundaries.
     |      ncolors : int
     |          Number of colors in the colormap to be used.
     |      clip : bool, optional
     |          If clip is ``True``, out of range values are mapped to 0 if they
     |          are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they
     |          are above ``boundaries[-1]``.
     |      
     |          If clip is ``False``, out of range values are mapped to -1 if
     |          they are below ``boundaries[0]`` or mapped to *ncolors* if they are
     |          above ``boundaries[-1]``. These are then converted to valid indices
     |          by `Colormap.__call__`.
     |      extend : {'neither', 'both', 'min', 'max'}, default: 'neither'
     |          Extend the number of bins to include one or both of the
     |          regions beyond the boundaries.  For example, if ``extend``
     |          is 'min', then the color to which the region between the first
     |          pair of boundaries is mapped will be distinct from the first
     |          color in the colormap, and by default a
     |          `~matplotlib.colorbar.Colorbar` will be drawn with
     |          the triangle extension on the left or lower end.
     |      
     |      Returns
     |      -------
     |      int16 scalar or array
     |      
     |      Notes
     |      -----
     |      *boundaries* defines the edges of bins, and data falling within a bin
     |      is mapped to the color with the same index.
     |      
     |      If the number of bins, including any extensions, is less than
     |      *ncolors*, the color index is chosen by linear interpolation, mapping
     |      the ``[0, nbins - 1]`` range onto the ``[0, ncolors - 1]`` range.
     |  
     |  inverse(self, value)
     |      Raises
     |      ------
     |      ValueError
     |          BoundaryNorm is not invertible, so calling this method will always
     |          raise an error
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class CenteredNorm(Normalize)
     |  CenteredNorm(vcenter=0, halfrange=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      CenteredNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vcenter=0, halfrange=None, clip=False)
     |      Normalize symmetrical data around a center (0 by default).
     |      
     |      Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change
     |      around the center.
     |      
     |      Useful when mapping symmetrical data around a conceptual center
     |      e.g., data that range from -2 to 4, with 0 as the midpoint, and
     |      with equal rates of change around that midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float, default: 0
     |          The data value that defines ``0.5`` in the normalization.
     |      halfrange : float, optional
     |          The range of data values that defines a range of ``0.5`` in the
     |          normalization, so that *vcenter* - *halfrange* is ``0.0`` and
     |          *vcenter* + *halfrange* is ``1.0`` in the normalization.
     |          Defaults to the largest absolute difference to *vcenter* for
     |          the values in the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0
     |      (assuming equal rates of change above and below 0.0):
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> norm = mcolors.CenteredNorm(halfrange=4.0)
     |          >>> data = [-2., 0., 4.]
     |          >>> norm(data)
     |          array([0.25, 0.5 , 1.  ])
     |  
     |  autoscale(self, A)
     |      Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.
     |  
     |  autoscale_None(self, A)
     |      Set *vmin* and *vmax*.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  halfrange
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class ColorConverter(builtins.object)
     |  A class only kept for backwards compatibility.
     |  
     |  Its functionality is entirely provided by module-level functions.
     |  
     |  Static methods defined here:
     |  
     |  to_rgb(c)
     |      Convert *c* to an RGB color, silently dropping the alpha channel.
     |  
     |  to_rgba(c, alpha=None)
     |      Convert *c* to an RGBA color.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or ``np.ma.masked``
     |      
     |      alpha : float, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |      Returns
     |      -------
     |      tuple
     |          Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  to_rgba_array(c, alpha=None)
     |      Convert *c* to a (n, 4) array of RGBA colors.
     |      
     |      Parameters
     |      ----------
     |      c : Matplotlib color or array of colors
     |          If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
     |          row for each masked value or row in *c*.
     |      
     |      alpha : float or sequence of floats, optional
     |          If *alpha* is given, force the alpha value of the returned RGBA tuple
     |          to *alpha*.
     |      
     |          If None, the alpha value from *c* is used. If *c* does not have an
     |          alpha channel, then alpha defaults to 1.
     |      
     |          *alpha* is ignored for the color value ``"none"`` (case-insensitive),
     |          which always maps to ``(0, 0, 0, 0)``.
     |      
     |          If *alpha* is a sequence and *c* is a single color, *c* will be
     |          repeated to match the length of *alpha*.
     |      
     |      Returns
     |      -------
     |      array
     |          (n, 4) array of RGBA colors,  where each channel (red, green, blue,
     |          alpha) can assume values between 0 and 1.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  cache = {('black', None): (0.0, 0.0, 0.0, 1.0), ('white', None): (1.0,...
     |  
     |  colors = {'xkcd:cloudy blue': '#acc2d9', 'xkcd:dark paste... (0.75, 0....
    
    class Colormap(builtins.object)
     |  Colormap(name, N=256)
     |  
     |  Baseclass for all scalar to RGBA mappings.
     |  
     |  Typically, Colormap instances are used to convert data values (floats)
     |  from the interval ``[0, 1]`` to the RGBA color that the respective
     |  Colormap represents. For scaling of data into the ``[0, 1]`` interval see
     |  `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`
     |  make heavy use of this ``data -> normalize -> map-to-color`` processing
     |  chain.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, name, N=256)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      .. note:: This function is not implemented for base class.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.reversed
     |      ListedColormap.reversed
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __hash__ = None
    
    class FuncNorm(FuncNorm)
     |  FuncNorm(functions, vmin=None, vmax=None, clip=False)
     |  
     |  Arbitrary normalization using functions for the forward and inverse.
     |  
     |  Parameters
     |  ----------
     |  functions : (callable, callable)
     |      two-tuple of the forward and inverse functions for the normalization.
     |      The forward function must be monotonic.
     |  
     |      Both functions must have the signature ::
     |  
     |         def forward(values: array-like) -> array-like
     |  
     |  vmin, vmax : float or None
     |      If *vmin* and/or *vmax* is not given, they are initialized from the
     |      minimum and maximum value, respectively, of the first input
     |      processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |  
     |  clip : bool, default: False
     |      If ``True`` values falling outside the range ``[vmin, vmax]``,
     |      are mapped to 0 or 1, whichever is closer, and masked values are
     |      set to 1.  If ``False`` masked values remain masked.
     |  
     |      Clipping silently defeats the purpose of setting the over, under,
     |      and masked colors in a colormap, so it is likely to lead to
     |      surprises; therefore the default is ``clip=False``.
     |  
     |  Method resolution order:
     |      FuncNorm
     |      FuncNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, functions, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class LightSource(builtins.object)
     |  LightSource(azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |  
     |  Create a light source coming from the specified azimuth and elevation.
     |  Angles are in degrees, with the azimuth measured
     |  clockwise from north and elevation up from the zero plane of the surface.
     |  
     |  `shade` is used to produce "shaded" rgb values for a data array.
     |  `shade_rgb` can be used to combine an rgb image with an elevation map.
     |  `hillshade` produces an illumination map of a surface.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1, hsv_min_sat=1, hsv_max_sat=0)
     |      Specify the azimuth (measured clockwise from south) and altitude
     |      (measured up from the plane of the surface) of the light source
     |      in degrees.
     |      
     |      Parameters
     |      ----------
     |      azdeg : float, default: 315 degrees (from the northwest)
     |          The azimuth (0-360, degrees clockwise from North) of the light
     |          source.
     |      altdeg : float, default: 45 degrees
     |          The altitude (0-90, degrees up from horizontal) of the light
     |          source.
     |      
     |      Notes
     |      -----
     |      For backwards compatibility, the parameters *hsv_min_val*,
     |      *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at
     |      initialization as well.  However, these parameters will only be used if
     |      "blend_mode='hsv'" is passed into `shade` or `shade_rgb`.
     |      See the documentation for `blend_hsv` for more details.
     |  
     |  blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None, hsv_min_val=None, hsv_min_sat=None)
     |      Take the input data array, convert to HSV values in the given colormap,
     |      then adjust those color values to give the impression of a shaded
     |      relief map with a specified light source.  RGBA values are returned,
     |      which can then be used to plot the shaded image with imshow.
     |      
     |      The color of the resulting image will be darkened by moving the (s, v)
     |      values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
     |      shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,
     |      hsv_max_val) in regions that are illuminated.  The default extremes are
     |      chose so that completely shaded points are nearly black (s = 1, v = 0)
     |      and completely illuminated points are nearly white (s = 0, v = 1).
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      hsv_max_sat : number, default: 1
     |          The maximum saturation value that the *intensity* map can shift the
     |          output image to.
     |      hsv_min_sat : number, optional
     |          The minimum saturation value that the *intensity* map can shift the
     |          output image to. Defaults to 0.
     |      hsv_max_val : number, optional
     |          The maximum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 1.
     |      hsv_min_val : number, optional
     |          The minimum value ("v" in "hsv") that the *intensity* map can shift
     |          the output image to. Defaults to 0.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_overlay(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "overlay" blending.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  blend_soft_light(self, rgb, intensity)
     |      Combine an rgb image with an intensity map using "soft light" blending,
     |      using the "pegtop" formula.
     |      
     |      Parameters
     |      ----------
     |      rgb : ndarray
     |          An MxNx3 RGB array of floats ranging from 0 to 1 (color image).
     |      intensity : ndarray
     |          An MxNx1 array of floats ranging from 0 to 1 (grayscale image).
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx3 RGB array representing the combined images.
     |  
     |  hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.0)
     |      Calculate the illumination intensity for a surface using the defined
     |      azimuth and elevation for the light source.
     |      
     |      This computes the normal vectors for the surface, and then passes them
     |      on to `shade_normals`
     |      
     |      Parameters
     |      ----------
     |      elevation : 2D array-like
     |          The height values used to generate an illumination map
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topographic effects.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None, vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs)
     |      Combine colormapped data values with an illumination intensity map
     |      (a.k.a.  "hillshade") of the values.
     |      
     |      Parameters
     |      ----------
     |      data : 2D array-like
     |          The height values used to generate a shaded map.
     |      cmap : `~matplotlib.colors.Colormap`
     |          The colormap used to color the *data* array. Note that this must be
     |          a `~matplotlib.colors.Colormap` instance.  For example, rather than
     |          passing in ``cmap='gist_earth'``, use
     |          ``cmap=plt.get_cmap('gist_earth')`` instead.
     |      norm : `~matplotlib.colors.Normalize` instance, optional
     |          The normalization used to scale values before colormapping. If
     |          None, the input will be linearly scaled between its min and max.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data
     |          values with the illumination intensity.  Default is
     |          "overlay".  Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to
     |          combine an MxNx3 RGB array of floats (ranging 0 to 1) with
     |          an MxNx1 hillshade array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``) Additional kwargs supplied
     |          to this function will be passed on to the *blend_mode*
     |          function.
     |      vmin : float or None, optional
     |          The minimum value used in colormapping *data*. If *None* the
     |          minimum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vmax : float or None, optional
     |          The maximum value used in colormapping *data*. If *None* the
     |          maximum value in *data* is used. If *norm* is specified, then this
     |          argument will be ignored.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An MxNx4 array of floats ranging between 0-1.
     |  
     |  shade_normals(self, normals, fraction=1.0)
     |      Calculate the illumination intensity for the normal vectors of a
     |      surface using the defined azimuth and elevation for the light source.
     |      
     |      Imagine an artificial sun placed at infinity in some azimuth and
     |      elevation position illuminating our surface. The parts of the surface
     |      that slope toward the sun should brighten while those sides facing away
     |      should become darker.
     |      
     |      Parameters
     |      ----------
     |      fraction : number, optional
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          A 2D array of illumination values between 0-1, where 0 is
     |          completely in shadow and 1 is completely illuminated.
     |  
     |  shade_rgb(self, rgb, elevation, fraction=1.0, blend_mode='hsv', vert_exag=1, dx=1, dy=1, **kwargs)
     |      Use this light source to adjust the colors of the *rgb* input array to
     |      give the impression of a shaded relief map with the given *elevation*.
     |      
     |      Parameters
     |      ----------
     |      rgb : array-like
     |          An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.
     |      elevation : array-like
     |          An (M, N) array of the height values used to generate a shaded map.
     |      fraction : number
     |          Increases or decreases the contrast of the hillshade.  Values
     |          greater than one will cause intermediate values to move closer to
     |          full illumination or shadow (and clipping any values that move
     |          beyond 0 or 1). Note that this is not visually or mathematically
     |          the same as vertical exaggeration.
     |      blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional
     |          The type of blending used to combine the colormapped data values
     |          with the illumination intensity.  For backwards compatibility, this
     |          defaults to "hsv". Note that for most topographic surfaces,
     |          "overlay" or "soft" appear more visually realistic. If a
     |          user-defined function is supplied, it is expected to combine an
     |          MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
     |          array (also 0 to 1).  (Call signature
     |          ``func(rgb, illum, **kwargs)``)
     |          Additional kwargs supplied to this function will be passed on to
     |          the *blend_mode* function.
     |      vert_exag : number, optional
     |          The amount to exaggerate the elevation values by when calculating
     |          illumination. This can be used either to correct for differences in
     |          units between the x-y coordinate system and the elevation
     |          coordinate system (e.g. decimal degrees vs. meters) or to
     |          exaggerate or de-emphasize topography.
     |      dx : number, optional
     |          The x-spacing (columns) of the input *elevation* grid.
     |      dy : number, optional
     |          The y-spacing (rows) of the input *elevation* grid.
     |      Additional kwargs are passed on to the *blend_mode* function.
     |      
     |      Returns
     |      -------
     |      ndarray
     |          An (m, n, 3) array of floats ranging between 0-1.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  direction
     |      The unit vector direction towards the light source.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LinearSegmentedColormap(Colormap)
     |  LinearSegmentedColormap(name, segmentdata, N=256, gamma=1.0)
     |  
     |  Colormap objects based on lookup tables using linear segments.
     |  
     |  The lookup table is generated using linear interpolation for each
     |  primary color, with the 0-1 domain divided into any number of
     |  segments.
     |  
     |  Method resolution order:
     |      LinearSegmentedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, name, segmentdata, N=256, gamma=1.0)
     |      Create colormap from linear mapping segments
     |      
     |      segmentdata argument is a dictionary with a red, green and blue
     |      entries. Each entry should be a list of *x*, *y0*, *y1* tuples,
     |      forming rows in a table. Entries for alpha are optional.
     |      
     |      Example: suppose you want red to increase from 0 to 1 over
     |      the bottom half, green to do the same over the middle half,
     |      and blue over the top half.  Then you would use::
     |      
     |          cdict = {'red':   [(0.0,  0.0, 0.0),
     |                             (0.5,  1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'green': [(0.0,  0.0, 0.0),
     |                             (0.25, 0.0, 0.0),
     |                             (0.75, 1.0, 1.0),
     |                             (1.0,  1.0, 1.0)],
     |      
     |                   'blue':  [(0.0,  0.0, 0.0),
     |                             (0.5,  0.0, 0.0),
     |                             (1.0,  1.0, 1.0)]}
     |      
     |      Each row in the table for a given color is a sequence of
     |      *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase
     |      monotonically from 0 to 1.  For any input value *z* falling
     |      between *x[i]* and *x[i+1]*, the output value of a given color
     |      will be linearly interpolated between *y1[i]* and *y0[i+1]*::
     |      
     |          row i:   x  y0  y1
     |                         /
     |                        /
     |          row i+1: x  y0  y1
     |      
     |      Hence y0 in the first row and y1 in the last row are never used.
     |      
     |      See Also
     |      --------
     |      LinearSegmentedColormap.from_list
     |          Static method; factory function for generating a smoothly-varying
     |          LinearSegmentedColormap.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      LinearSegmentedColormap
     |          The reversed colormap.
     |  
     |  set_gamma(self, gamma)
     |      Set a new gamma value and regenerate colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  from_list(name, colors, N=256, gamma=1.0)
     |      Create a `LinearSegmentedColormap` from a list of colors.
     |      
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      colors : array-like of colors or array-like of (value, color)
     |          If only colors are given, they are equidistantly mapped from the
     |          range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to
     |          ``colors[-1]``.
     |          If (value, color) pairs are given, the mapping is from *value*
     |          to *color*. This can be used to divide the range unevenly.
     |      N : int
     |          The number of rgb quantization levels.
     |      gamma : float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class ListedColormap(Colormap)
     |  ListedColormap(colors, name='from_list', N=None)
     |  
     |  Colormap object generated from a list of colors.
     |  
     |  This may be most useful when indexing directly into a colormap,
     |  but it can also be used to generate special colormaps for ordinary
     |  mapping.
     |  
     |  Parameters
     |  ----------
     |  colors : list, array
     |      List of Matplotlib color specifications, or an equivalent Nx3 or Nx4
     |      floating point array (*N* rgb or rgba values).
     |  name : str, optional
     |      String to identify the colormap.
     |  N : int, optional
     |      Number of entries in the map. The default is *None*, in which case
     |      there is one colormap entry for each element in the list of colors.
     |      If ::
     |  
     |          N < len(colors)
     |  
     |      the list will be truncated at *N*. If ::
     |  
     |          N > len(colors)
     |  
     |      the list will be extended by repetition.
     |  
     |  Method resolution order:
     |      ListedColormap
     |      Colormap
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, colors, name='from_list', N=None)
     |      Parameters
     |      ----------
     |      name : str
     |          The name of the colormap.
     |      N : int
     |          The number of rgb quantization levels.
     |  
     |  reversed(self, name=None)
     |      Return a reversed instance of the Colormap.
     |      
     |      Parameters
     |      ----------
     |      name : str, optional
     |          The name for the reversed colormap. If it's None the
     |          name will be the name of the parent colormap + "_r".
     |      
     |      Returns
     |      -------
     |      ListedColormap
     |          A reversed instance of the colormap.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Colormap:
     |  
     |  __call__(self, X, alpha=None, bytes=False)
     |      Parameters
     |      ----------
     |      X : float or int, ndarray or scalar
     |          The data value(s) to convert to RGBA.
     |          For floats, X should be in the interval ``[0.0, 1.0]`` to
     |          return the RGBA values ``X*100`` percent along the Colormap line.
     |          For integers, X should be in the interval ``[0, Colormap.N)`` to
     |          return RGBA values *indexed* from the Colormap with index ``X``.
     |      alpha : float or array-like or None
     |          Alpha must be a scalar between 0 and 1, a sequence of such
     |          floats with shape matching X, or None.
     |      bytes : bool
     |          If False (default), the returned RGBA values will be floats in the
     |          interval ``[0, 1]`` otherwise they will be uint8s in the interval
     |          ``[0, 255]``.
     |      
     |      Returns
     |      -------
     |      Tuple of RGBA values if X is scalar, otherwise an array of
     |      RGBA values with a shape of ``X.shape + (4, )``.
     |  
     |  __copy__(self)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  copy(self)
     |      Return a copy of the colormap.
     |  
     |  get_bad(self)
     |      Get the color for masked values.
     |  
     |  get_over(self)
     |      Get the color for high out-of-range values.
     |  
     |  get_under(self)
     |      Get the color for low out-of-range values.
     |  
     |  is_gray(self)
     |      Return whether the colormap is grayscale.
     |  
     |  set_bad(self, color='k', alpha=None)
     |      Set the color for masked values.
     |  
     |  set_extremes(self, *, bad=None, under=None, over=None)
     |      Set the colors for masked (*bad*) values and, when ``norm.clip =
     |      False``, low (*under*) and high (*over*) out-of-range values.
     |  
     |  set_over(self, color='k', alpha=None)
     |      Set the color for high out-of-range values.
     |  
     |  set_under(self, color='k', alpha=None)
     |      Set the color for low out-of-range values.
     |  
     |  with_extremes(self, *, bad=None, under=None, over=None)
     |      Return a copy of the colormap, for which the colors for masked (*bad*)
     |      values and, when ``norm.clip = False``, low (*under*) and high (*over*)
     |      out-of-range values, have been set accordingly.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Colormap:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Colormap:
     |  
     |  __hash__ = None
    
    class LogNorm(LogNorm)
     |  LogNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Normalize a given value to the 0-1 range on a log scale.
     |  
     |  Method resolution order:
     |      LogNorm
     |      LogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from LogNorm:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class NoNorm(Normalize)
     |  NoNorm(vmin=None, vmax=None, clip=False)
     |  
     |  Dummy replacement for `Normalize`, for the case where we want to use
     |  indices directly in a `~matplotlib.cm.ScalarMappable`.
     |  
     |  Method resolution order:
     |      NoNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class Normalize(builtins.object)
     |  Normalize(vmin=None, vmax=None, clip=False)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  inverse(self, value)
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class PowerNorm(Normalize)
     |  PowerNorm(gamma, vmin=None, vmax=None, clip=False)
     |  
     |  Linearly map a given value to the 0-1 range and then apply
     |  a power-law normalization over that range.
     |  
     |  Method resolution order:
     |      PowerNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Normalize *value* data in the ``[vmin, vmax]`` interval into the
     |      ``[0.0, 1.0]`` interval and return it.
     |      
     |      Parameters
     |      ----------
     |      value
     |          Data to normalize.
     |      clip : bool
     |          If ``None``, defaults to ``self.clip`` (which defaults to
     |          ``False``).
     |      
     |      Notes
     |      -----
     |      If not already initialized, ``self.vmin`` and ``self.vmax`` are
     |      initialized using ``self.autoscale_None(value)``.
     |  
     |  __init__(self, gamma, vmin=None, vmax=None, clip=False)
     |      Parameters
     |      ----------
     |      vmin, vmax : float or None
     |          If *vmin* and/or *vmax* is not given, they are initialized from the
     |          minimum and maximum value, respectively, of the first input
     |          processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.
     |      
     |      clip : bool, default: False
     |          If ``True`` values falling outside the range ``[vmin, vmax]``,
     |          are mapped to 0 or 1, whichever is closer, and masked values are
     |          set to 1.  If ``False`` masked values remain masked.
     |      
     |          Clipping silently defeats the purpose of setting the over, under,
     |          and masked colors in a colormap, so it is likely to lead to
     |          surprises; therefore the default is ``clip=False``.
     |      
     |      Notes
     |      -----
     |      Returns 0 if ``vmin == vmax``.
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class SymLogNorm(SymLogNorm)
     |  SymLogNorm(linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  The symmetrical logarithmic scale is logarithmic in both the
     |  positive and negative directions from the origin.
     |  
     |  Since the values close to zero tend toward infinity, there is a
     |  need to have a range around zero that is linear.  The parameter
     |  *linthresh* allows the user to specify the size of this range
     |  (-*linthresh*, *linthresh*).
     |  
     |  Parameters
     |  ----------
     |  linthresh : float
     |      The range within which the plot is linear (to avoid having the plot
     |      go to infinity around zero).
     |  linscale : float, default: 1
     |      This allows the linear range (-*linthresh* to *linthresh*) to be
     |      stretched relative to the logarithmic range. Its value is the
     |      number of decades to use for each half of the linear range. For
     |      example, when *linscale* == 1.0 (the default), the space used for
     |      the positive and negative halves of the linear range will be equal
     |      to one decade in the logarithmic range.
     |  base : float, default: 10
     |  
     |  Method resolution order:
     |      SymLogNorm
     |      SymLogNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |  
     |  __init__(self, linthresh, linscale=1.0, vmin=None, vmax=None, clip=False, *, base=10)
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SymLogNorm:
     |  
     |  linthresh
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  autoscale_None(self, A)
     |      If vmin or vmax are not set, use the min/max of *A* to set them.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin
    
    class TwoSlopeNorm(Normalize)
     |  TwoSlopeNorm(vcenter, vmin=None, vmax=None)
     |  
     |  A class which, when called, linearly normalizes data into the
     |  ``[0.0, 1.0]`` interval.
     |  
     |  Method resolution order:
     |      TwoSlopeNorm
     |      Normalize
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __call__(self, value, clip=None)
     |      Map value to the interval [0, 1]. The clip argument is unused.
     |  
     |  __init__(self, vcenter, vmin=None, vmax=None)
     |      Normalize data with a set center.
     |      
     |      Useful when mapping data with an unequal rates of change around a
     |      conceptual center, e.g., data that range from -2 to 4, with 0 as
     |      the midpoint.
     |      
     |      Parameters
     |      ----------
     |      vcenter : float
     |          The data value that defines ``0.5`` in the normalization.
     |      vmin : float, optional
     |          The data value that defines ``0.0`` in the normalization.
     |          Defaults to the min value of the dataset.
     |      vmax : float, optional
     |          The data value that defines ``1.0`` in the normalization.
     |          Defaults to the max value of the dataset.
     |      
     |      Examples
     |      --------
     |      This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data
     |      between is linearly interpolated::
     |      
     |          >>> import matplotlib.colors as mcolors
     |          >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,
     |                                            vcenter=0., vmax=10000)
     |          >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]
     |          >>> offset(data)
     |          array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])
     |  
     |  autoscale_None(self, A)
     |      Get vmin and vmax, and then clip at vcenter
     |  
     |  inverse(self, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  vcenter
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Normalize:
     |  
     |  autoscale(self, A)
     |      Set *vmin*, *vmax* to min, max of *A*.
     |  
     |  scaled(self)
     |      Return whether vmin and vmax are set.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from Normalize:
     |  
     |  process_value(value)
     |      Homogenize the input *value* for easy and efficient normalization.
     |      
     |      *value* can be a scalar or sequence.
     |      
     |      Returns
     |      -------
     |      result : masked array
     |          Masked array with the same shape as *value*.
     |      is_scalar : bool
     |          Whether *value* is a scalar.
     |      
     |      Notes
     |      -----
     |      Float dtypes are preserved; integer types with two bytes or smaller are
     |      converted to np.float32, and larger types are converted to np.float64.
     |      Preserving float32 when possible, and using in-place operations,
     |      greatly improves speed for large arrays.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Normalize:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  clip
     |  
     |  vmax
     |  
     |  vmin

FUNCTIONS
    from_levels_and_colors(levels, colors, extend='neither')
        A helper routine to generate a cmap and a norm instance which
        behave similar to contourf's levels and colors arguments.
        
        Parameters
        ----------
        levels : sequence of numbers
            The quantization levels used to construct the `BoundaryNorm`.
            Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.
        colors : sequence of colors
            The fill color to use for each level. If *extend* is "neither" there
            must be ``n_level - 1`` colors. For an *extend* of "min" or "max" add
            one extra color, and for an *extend* of "both" add two colors.
        extend : {'neither', 'min', 'max', 'both'}, optional
            The behaviour when a value falls out of range of the given levels.
            See `~.Axes.contourf` for details.
        
        Returns
        -------
        cmap : `~matplotlib.colors.Normalize`
        norm : `~matplotlib.colors.Colormap`
    
    get_named_colors_mapping()
        Return the global mapping of names to named colors.
    
    hex2color = to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    hsv_to_rgb(hsv)
        Convert hsv values to rgb.
        
        Parameters
        ----------
        hsv : (..., 3) array-like
           All values assumed to be in range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to RGB values in range [0, 1]
    
    is_color_like(c)
        Return whether *c* can be interpreted as an RGB(A) color.
    
    make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None)
        Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`
        subclass.
        
        After ::
        
            @make_norm_from_scale(scale_cls)
            class norm_cls(Normalize):
                ...
        
        *norm_cls* is filled with methods so that normalization computations are
        forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used
        for the colorbar of a mappable normalized with *norm_cls*).
        
        If *init* is not passed, then the constructor signature of *norm_cls*
        will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three
        parameters will be forwarded to the base class (``Normalize.__init__``),
        and a *scale_cls* object will be initialized with no arguments (other than
        a dummy axis).
        
        If the *scale_cls* constructor takes additional parameters, then *init*
        should be passed to `make_norm_from_scale`.  It is a callable which is
        *only* used for its signature.  First, this signature will become the
        signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the
        parameters passed to it using this signature, extract the bound *vmin*,
        *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and
        forward the remaining bound values (including any defaults defined by the
        signature) to the *scale_cls* constructor.
    
    rgb2hex = to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    rgb_to_hsv(arr)
        Convert float rgb values (in the range [0, 1]), in a numpy array to hsv
        values.
        
        Parameters
        ----------
        arr : (..., 3) array-like
           All values must be in the range [0, 1]
        
        Returns
        -------
        (..., 3) ndarray
           Colors converted to hsv values in range [0, 1]
    
    same_color(c1, c2)
        Return whether the colors *c1* and *c2* are the same.
        
        *c1*, *c2* can be single colors or lists/arrays of colors.
    
    to_hex(c, keep_alpha=False)
        Convert *c* to a hex color.
        
        Parameters
        ----------
        c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`
        
        keep_alpha: bool, default: False
          If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.
        
        Returns
        -------
        str
          ``#rrggbb`` or ``#rrggbbaa`` hex color string
    
    to_rgb(c)
        Convert *c* to an RGB color, silently dropping the alpha channel.
    
    to_rgba(c, alpha=None)
        Convert *c* to an RGBA color.
        
        Parameters
        ----------
        c : Matplotlib color or ``np.ma.masked``
        
        alpha : float, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
        Returns
        -------
        tuple
            Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.
    
    to_rgba_array(c, alpha=None)
        Convert *c* to a (n, 4) array of RGBA colors.
        
        Parameters
        ----------
        c : Matplotlib color or array of colors
            If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)
            row for each masked value or row in *c*.
        
        alpha : float or sequence of floats, optional
            If *alpha* is given, force the alpha value of the returned RGBA tuple
            to *alpha*.
        
            If None, the alpha value from *c* is used. If *c* does not have an
            alpha channel, then alpha defaults to 1.
        
            *alpha* is ignored for the color value ``"none"`` (case-insensitive),
            which always maps to ``(0, 0, 0, 0)``.
        
            If *alpha* is a sequence and *c* is a single color, *c* will be
            repeated to match the length of *alpha*.
        
        Returns
        -------
        array
            (n, 4) array of RGBA colors,  where each channel (red, green, blue,
            alpha) can assume values between 0 and 1.

DATA
    BASE_COLORS = {'b': (0, 0, 1), 'c': (0, 0.75, 0.75), 'g': (0, 0.5, 0),...
    CSS4_COLORS = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqu...
    TABLEAU_COLORS = {'tab:blue': '#1f77b4', 'tab:brown': '#8c564b', 'tab:...
    XKCD_COLORS = {'xkcd:acid green': '#8ffe09', 'xkcd:adobe': '#bd6c48', ...
    cnames = {'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '...
    colorConverter = <matplotlib.colors.ColorConverter object>
    hexColorPattern = re.compile('\\A#[a-fA-F0-9]{6}\\Z')

FILE
    c:\users\johns\appdata\local\packages\pythonsoftwarefoundation.python.3.8_qbz5n2kfra8p0\localcache\local-packages\python38\site-packages\matplotlib\colors.py


FAIL
0
max length: 194
Resetting...
Worked Total: 29
0
Resetting...
Worked Total: 30
0
Resetting...
Worked Total: 31
0
Resetting...
The following numbers are abundant
does not work -- need to run options
The following numbers are abundant
The following numbers are abundant
FAIL
0
Resetting...
Worked Total: 32
0
max length: 32
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
Worked Total: 33
0
max length: 68
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
hello
Worked Total: 34
0
Resetting...
['T', 'h', 'i', 's', ' ']
['T', 'h']
['T', 'h', 'i', 's']
[' ', 'i', 's', ' ', 't', 'h', 'e', ' ', 'l', 'i', 'n', 'e', ' ', 'I', ' ', 'a', 'm', ' ', 'g', 'o', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'p', 'r', 'a', 'c', 't', 'i', 'c', 'e', ' ', 'o', 'n']
['T', 'i', ' ', 's', 't', 'e', 'l', 'n', ' ', ' ', 'm', 'g', 'i', 'g', 't', ' ', 'r', 'c', 'i', 'e', 'o']
Worked Total: 35
0
Resetting...
Loop 0
Loop 1
Loop 2
Else block
Loop 0
Loop 1
While else block!
While else block!
Testing 2
Testing 3
Testing 4
Coprime
Worked Total: 36
0
Resetting...
Worked Total: 37
0
Resetting...
Worked Total: 38
0
max length: 43
Resetting...
Worked Total: 39
0
max length: 11
Resetting...
does not work -- need to run options
[1, [2, [3, 4], 5], 6]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[-10, -5, -4]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[1, [2, [3, 4], 5], 6]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[-10, -5, -4]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[1, [2, [3, 4], 5], 6]
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[-10, -5, -4]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[-10, -5, -4]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[1, [2, [3, 4], 5], 6]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[-10, -5, -4]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[1, [2, [3, 4], 5], 6]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[-10, -5, -4]
[1, [2, [3, 4], 5], 6]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[-10, -5, -4]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[-10, -5, -4]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
[('0F', '-17.8C'), ('5F', '-15.0C'), ('10F', '-12.2C'), ('15F', '-9.4C'), ('20F', '-6.7C'), ('25F', '-3.9C'), ('30F', '-1.1C'), ('35F', '1.7C'), ('40F', '4.4C'), ('45F', '7.2C'), ('50F', '10.0C'), ('55F', '12.8C'), ('60F', '15.6C'), ('65F', '18.3C'), ('70F', '21.1C'), ('75F', '23.9C'), ('80F', '26.7C'), ('85F', '29.4C'), ('90F', '32.2C'), ('95F', '35.0C'), ('100F', '37.8C')]
(3, 4, 5)
(5, 12, 13)
(6, 8, 10)
(8, 15, 17)
(9, 12, 15)
(12, 16, 20)
FAIL
0
Resetting...
Worked Total: 40
0
Resetting...
Worked Total: 41
0
max length: 14
Resetting...
[{'name': 'Zophie', 'age': 7, 'color': 'gray'}, {'name': 'Fooka', 'age': 5, 'color': 'black'}, {'name': 'Fat-tail', 'age': 5, 'color': 'gray'}, {'name': '???', 'age': -1, 'color': 'orange'}]
{'low-L': ' ',
 'low-M': ' ',
 'low-R': ' ',
 'mid-L': ' ',
 'mid-M': ' ',
 'mid-R': ' ',
 'top-L': ' ',
 'top-M': ' ',
 'top-R': ' '}
{'low-L': ' ',
 'low-M': ' ',
 'low-R': ' ',
 'mid-L': ' ',
 'mid-M': 'X',
 'mid-R': ' ',
 'top-L': ' ',
 'top-M': ' ',
 'top-R': ' '}
  |   |  
----------
  | X |  
----------
  |   |  
type(42)
<class 'int'>
type(hello)
<class 'str'>
type(3.14)
<class 'float'>
type(theBoard)
<class 'dict'>
type(theBoard[top-R])
<class 'str'>
Worked Total: 42
0
Resetting...
Worked Total: 43
0
Resetting...
Worked Total: 44
0
Resetting...
Worked Total: 45
0
max length: 36
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
Worked Total: 46
0
max length: 14
Resetting...
Worked Total: 47
0
max length: 35
Resetting...
does not work -- need to run options
FAIL
0
max length: 18
Resetting...
does not work -- need to run options
FAIL
0
max length: 10
Resetting...
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
does not work -- need to run options
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
0.6
0.5
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
['m', 'r', 't'] ['e', 'm', 'r']
['e', 'm', 'r']
['e', 'm', 'r']
FAIL
0
max length: 79
Resetting...
does not work -- need to run options
FAIL
0
max length: 42
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
does not work -- need to run options
FAIL
0
max length: 14
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
Worked Total: 48
0
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
[1 2 3 4]
[[ 1.  1.  1.  1.]
 [ 1.  2.  4.  8.]
 [ 1.  3.  9. 27.]
 [ 1.  4. 16. 64.]]
[2. 2. 2. 2. 2. 2. 2. 2. 2. 2.]
[ 1  2  3  4  5  6  7  8  9 10]
[[  1.   1.   1.   2.   2.   2.   4.   4.   4.]
 [  1.   2.   4.   2.   4.   8.   4.   8.  16.]
 [  1.   3.   9.   2.   6.  18.   4.  12.  36.]
 [  1.   4.  16.   2.   8.  32.   4.  16.  64.]
 [  1.   5.  25.   2.  10.  50.   4.  20. 100.]
 [  1.   6.  36.   2.  12.  72.   4.  24. 144.]
 [  1.   7.  49.   2.  14.  98.   4.  28. 196.]
 [  1.   8.  64.   2.  16. 128.   4.  32. 256.]
 [  1.   9.  81.   2.  18. 162.   4.  36. 324.]
 [  1.  10. 100.   2.  20. 200.   4.  40. 400.]]
Worked Total: 49
0
max length: 61
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
['data/customers.csv', 'data/products.csv']
/tmp
all
True
Worked Total: 50
0
Resetting...
monday ,drink coffee ,eat banana ,enjoy cake
tuesdat ,drink tea ,eat orange ,enjoy ice cream
wednesday ,drink beer ,eat peach ,enjoy pie
quack
Positional argument tuple: ()
Positional argument tuple: (3, 2, 1, 'wait!', 'uh....')
need this one: cap
need this one too: gloves
all the rest: ('scarf', 'monocle', 'mustache max')
keyword argument: {'wine': 'merlot', 'entree': 'mutton', 'dessert': 'macaroon'}
Worked Total: 51
0
Resetting...
5
4
3
2
1
Good Morning \OWO/
does not work -- need to run options
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
Moe said: A wise guy, huh?
Be that as it may
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
Moe said: A wise guy, huh?
Be that as it may
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Be that as it may
Moe said: A wise guy, huh?
Be that as it may
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
5
4
3
2
1
Good Morning \OWO/
Moe said: A wise guy, huh?
FAIL
0
Resetting...
does not work -- need to run options
FAIL
0
Resetting...
Worked Total: 52
0
Resetting...
1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 Fizzbuzz
16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 Fizzbuzz
31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 Fizzbuzz
46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 Fizzbuzz
61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 Fizzbuzz
76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 Fizzbuzz
91 92 fizz 94 buzz fizz 97 98 fizz buzz Worked Total: 53
0
max length: 11
Resetting...
just right
too low
too low
too low
too low
too low
too low
found it !
3
2
1
0
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
Got 0
Got 1
Got 2
Got 3
Got 4
Got 5
Got 6
Got 7
Got 8
Got 9
5
Worked Total: 54
0
max length: 23
Resetting...
0.9781159420289856
{'clf__C': 0.1, 'clf__kernel': 'linear'}
Test accuracy : 0.965
CV accuracy: 0.965 +/- 0.025
CV accuracy: 0.921 +/- 0.029
Worked Total: 55
0
max length: 42
Resetting...
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
does not work -- need to run options
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
True
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
KAAA
KBAB
True
KAAA
KBAB
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
KAAA
KBAB
True
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
KAAA
KBAB
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
KAAA
KBAB
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
KAAA
KBAB
True
KAAA
KBAB
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
KAAA
KBAB
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
What's that on Subject A's leg? special_tattoo
Lassie
steak
['play dead']
{'name': 'Lassie', 'favorite': 'steak'}
True
FAIL
0
max length: 71
Resetting...
does not work -- need to run options
EEEE
======================================================================
ERROR: test_function (__main__.TestComposer)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 71, in <module>
  File "<string>", line 22, in __mul__
NameError: name 'types' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 13, in test_function
NameError: name 'Composable' is not defined

======================================================================
ERROR: test_inputs (__main__.TestComposer)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 71, in <module>
  File "<string>", line 22, in __mul__
NameError: name 'types' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 23, in test_inputs
NameError: name 'Composable' is not defined

======================================================================
ERROR: test_powering (__main__.TestComposer)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 71, in <module>
  File "<string>", line 22, in __mul__
NameError: name 'types' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 33, in test_powering
NameError: name 'Composable' is not defined

======================================================================
ERROR: test_simple (__main__.TestComposer)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Users\johns\AppData\Local\Temp/ipykernel_5572/3029923366.py", line 11, in find_solution
    exec(answer, None, local) # check if OG code works
  File "<string>", line 71, in <module>
  File "<string>", line 22, in __mul__
NameError: name 'types' is not defined

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<string>", line 8, in test_simple
NameError: name 'f' is not defined

----------------------------------------------------------------------
Ran 4 tests in 0.002s

FAILED (errors=4)
FAIL
0
max length: 53
Resetting...
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
does not work -- need to run options
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197


scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197


scissors
paper
rock


phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
scissors
paper
rock
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

scissors
paper
rock
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197


scissors
paper
rock

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock


phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
scissors
paper
rock

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197


scissors
paper
rock

phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197

scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock

scissors
paper
rock
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
phi ** -4 == 0.14589803
phi ** -3 == 0.23606798
phi ** -2 == 0.38196601
phi ** -1 == 0.61803399
phi **  0 == 1.00000000
phi **  1 == 1.61803399
phi **  2 == 2.61803399
phi **  3 == 4.23606798
phi **  4 == 6.85410197
scissors
paper
rock
FAIL
0
max length: 20
Resetting...
Worked Total: 56
0
Resetting...
Worked Total: 57
0
Resetting...
does not work -- need to run options
FAIL
0
max length: 11
Resetting...
Q:
 [[ 0.85714286 -0.39428571 -0.33142857]
 [ 0.42857143  0.90285714  0.03428571]
 [-0.28571429  0.17142857 -0.94285714]]
R:
 [[ 1.40000000e+01  2.10000000e+01 -1.40000000e+01]
 [-2.22044605e-16  1.75000000e+02 -7.00000000e+01]
 [-1.33226763e-15 -1.95399252e-14  3.50000000e+01]]
Worked Total: 58
0
max length: 56
Resetting...
does not work -- need to run options
FAIL
0
max length: 303
Resetting...
does not work -- need to run options
Shape hook numbers:
All permutations of standard tableau for shape:
Shape hook numbers:
All permutations of standard tableau for shape:
All permutations of standard tableau for shape:
All permutations of standard tableau for shape:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
All permutations of standard tableau for shape:
Shape hook numbers:
Shape hook numbers:
All permutations of standard tableau for shape:
All permutations of standard tableau for shape:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
Shape hook numbers:
All permutations of standard tableau for shape:
All permutations of standard tableau for shape:
Shape hook numbers:
All permutations of standard tableau for shape:
Shape hook numbers:
All permutations of standard tableau for shape:
FAIL
0
max length: 13
Resetting...
Worked Total: 59
0
max length: 23
Resetting...
Worked Total: 60
0
Resetting...
Worked Total: 61
0
max length: 28
Resetting...
Mean x = 14294.6
StDev x = 37793.0
[-0.378 -0.378 -0.378  2.268 -0.378 -0.378 -0.378]
Median x = 10.0
[ 0.     0.     0.     2.646 -0.     0.     0.   ]
IQR = 1.0
[     0.         1.349      0.    134887.859     -1.349      0.
      1.349]
IQR = 24998.75 :(
[-0.    -0.     0.     5.396]
IQR = 743.50 :(
[  1.795  -0.003  -0.003  -0.001   0.001 181.422]
IQR = 496.50 :(
[  2.69   -0.003  -0.003  -0.003   0.      0.003 271.677]
Abs median difference
[  990.     1.     1.     1.     0.     1. 99991.]
MAD = 1.000
does not work -- need to run options
FAIL
0
Resetting...
does not work -- need to run options
FAIL
0
max length: 31
Resetting...
does not work -- need to run options
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
D - 4
Q - 4
H - 4
T - 3
W - 3
M - 6
Y - 8
A - 6
E - 5
G - 5
L - 5
N - 3
V - 2
R - 2
C - 3
K - 4
S - 2
F - 3
P - 3
I - 1
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
hydrophobic - 0.4473684210526316
positive - 0.13157894736842105
negative - 0.11842105263157894
polar - 0.15789473684210525
other - 0.14473684210526316
FAIL
0
Resetting...
Worked Total: 62
0
Resetting...
Worked Total: 63
0
max length: 45
Resetting...
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
does not work -- need to run options
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Laplacian
[[ 2  0 -1  0  0 -1  0  0]
 [ 0  2  0  0 -1  0  0 -1]
 [-1  0  3 -1  0 -1  0  0]
 [ 0  0 -1  3 -1  0 -1  0]
 [ 0 -1  0 -1  3  0  0 -1]
 [-1  0 -1  0  0  3 -1  0]
 [ 0  0  0  0 -1 -1  3 -1]
 [ 0 -1  0  0 -1  0 -1  3]]

1: True
2: True
3: False
4: False
Eigenvector
[ 0.5  0.   0.5 -0.  -0.5 -0.5]

1: True
2: False
2: False
4: False
FAIL
0
max length: 13
Resetting...
Worked Total: 64
File copied from ./testing_vaild_code\01 Pandas dataframe.ipynb to went_through_mine_worked\01 Pandas dataframe.ipynb
File copied from ./testing_vaild_code\01_Bayes_Theorem.ipynb to went_through_mine_worked\01_Bayes_Theorem.ipynb
File copied from ./testing_vaild_code\03_Visual_Psychophysics.ipynb to went_through_mine_worked\03_Visual_Psychophysics.ipynb
File copied from ./testing_vaild_code\2015-09-28-OpeningPost.ipynb to went_through_mine_worked\2015-09-28-OpeningPost.ipynb
File copied from ./testing_vaild_code\add_mean_median_numpy.ipynb to went_through_mine_worked\add_mean_median_numpy.ipynb
File copied from ./testing_vaild_code\AoC - Day 4 The Ideal Stocking Stuffer.ipynb to went_through_mine_worked\AoC - Day 4 The Ideal Stocking Stuffer.ipynb
File copied from ./testing_vaild_code\Assignment06 -- Orbital variations and insolation.ipynb to went_through_mine_worked\Assignment06 -- Orbital variations and insolation.ipynb
File copied from ./testing_vaild_code\B10409006', '1102.ipynb to went_through_mine_worked\B10409006', '1102.ipynb
File copied from ./testing_vaild_code\bin_edges.ipynb to went_through_mine_worked\bin_edges.ipynb
File copied from ./testing_vaild_code\ceteiep_maths101', 'ceteiep_maths101_20161026b.ipynb to went_through_mine_worked\ceteiep_maths101', 'ceteiep_maths101_20161026b.ipynb
File copied from ./testing_vaild_code\ceteiep_maths101', 'ceteiep_maths101_exercises_set3.ipynb to went_through_mine_worked\ceteiep_maths101', 'ceteiep_maths101_exercises_set3.ipynb
File copied from ./testing_vaild_code\Ch28 - A More Realistic Example.ipynb to went_through_mine_worked\Ch28 - A More Realistic Example.ipynb
File copied from ./testing_vaild_code\clases_python', 'Clase2.ipynb to went_through_mine_worked\clases_python', 'Clase2.ipynb
File copied from ./testing_vaild_code\CodeToy', 'ProjectEuler001.ipynb to went_through_mine_worked\CodeToy', 'ProjectEuler001.ipynb
File copied from ./testing_vaild_code\Codility - MinAvgTwoSlice.ipynb to went_through_mine_worked\Codility - MinAvgTwoSlice.ipynb
File copied from ./testing_vaild_code\cpw1', 'HI.ipynb to went_through_mine_worked\cpw1', 'HI.ipynb
File copied from ./testing_vaild_code\da-programming-1', 'week_02.ipynb to went_through_mine_worked\da-programming-1', 'week_02.ipynb
File copied from ./testing_vaild_code\DataAnalyticsLearning', 'Lecture 36 - Mapping.ipynb to went_through_mine_worked\DataAnalyticsLearning', 'Lecture 36 - Mapping.ipynb
File copied from ./testing_vaild_code\DataAnalyticsLearning', 'Lecture 40 - Outliers.ipynb to went_through_mine_worked\DataAnalyticsLearning', 'Lecture 40 - Outliers.ipynb
File copied from ./testing_vaild_code\Day5Homework.ipynb to went_through_mine_worked\Day5Homework.ipynb
File copied from ./testing_vaild_code\Divers', 'FormTestrecettes.ipynb to went_through_mine_worked\Divers', 'FormTestrecettes.ipynb
File copied from ./testing_vaild_code\DW06_GroupBy.ipynb to went_through_mine_worked\DW06_GroupBy.ipynb
File copied from ./testing_vaild_code\EntryPoll_bootcamp_experiments.ipynb to went_through_mine_worked\EntryPoll_bootcamp_experiments.ipynb
File copied from ./testing_vaild_code\example-template-notebook-out_0_a.ipynb to went_through_mine_worked\example-template-notebook-out_0_a.ipynb
File copied from ./testing_vaild_code\example-template-notebook.ipynb to went_through_mine_worked\example-template-notebook.ipynb
File copied from ./testing_vaild_code\Fall510', 'TEST1_PYTHON.ipynb to went_through_mine_worked\Fall510', 'TEST1_PYTHON.ipynb
File copied from ./testing_vaild_code\fecon235-08-sympy.ipynb to went_through_mine_worked\fecon235-08-sympy.ipynb
File copied from ./testing_vaild_code\GeneratorCompose.ipynb to went_through_mine_worked\GeneratorCompose.ipynb
File copied from ./testing_vaild_code\helper_sam.ipynb to went_through_mine_worked\helper_sam.ipynb
File copied from ./testing_vaild_code\hw1.ipynb to went_through_mine_worked\hw1.ipynb
File copied from ./testing_vaild_code\Hydraflix', 'Final_Code.ipynb to went_through_mine_worked\Hydraflix', 'Final_Code.ipynb
File copied from ./testing_vaild_code\Index Power.ipynb to went_through_mine_worked\Index Power.ipynb
File copied from ./testing_vaild_code\Ipython-notebook', 'RCI 2.0 Presentation.ipynb to went_through_mine_worked\Ipython-notebook', 'RCI 2.0 Presentation.ipynb
File copied from ./testing_vaild_code\ipython_notebook', 'try_github.ipynb to went_through_mine_worked\ipython_notebook', 'try_github.ipynb
File copied from ./testing_vaild_code\islice.ipynb to went_through_mine_worked\islice.ipynb
File copied from ./testing_vaild_code\Item12.ipynb to went_through_mine_worked\Item12.ipynb
File copied from ./testing_vaild_code\Jupyter-Notebooks', 'Lecture 10 - Array Transposition.ipynb to went_through_mine_worked\Jupyter-Notebooks', 'Lecture 10 - Array Transposition.ipynb
File copied from ./testing_vaild_code\Jupyter-Notebooks', 'Lecture 7 - Creating Arrays.ipynb to went_through_mine_worked\Jupyter-Notebooks', 'Lecture 7 - Creating Arrays.ipynb
File copied from ./testing_vaild_code\L1 - Olympics Medal Points.ipynb to went_through_mine_worked\L1 - Olympics Medal Points.ipynb
File copied from ./testing_vaild_code\least_squares.ipynb to went_through_mine_worked\least_squares.ipynb
File copied from ./testing_vaild_code\Lecture 14 - Series.ipynb to went_through_mine_worked\Lecture 14 - Series.ipynb
File copied from ./testing_vaild_code\lesson18.ipynb to went_through_mine_worked\lesson18.ipynb
File copied from ./testing_vaild_code\lesson3.ipynb to went_through_mine_worked\lesson3.ipynb
File copied from ./testing_vaild_code\Lover level.ipynb to went_through_mine_worked\Lover level.ipynb
File copied from ./testing_vaild_code\Math practice.ipynb to went_through_mine_worked\Math practice.ipynb
File copied from ./testing_vaild_code\matrix-vector.ipynb to went_through_mine_worked\matrix-vector.ipynb
File copied from ./testing_vaild_code\Mechanics 1 - Problem 6.ipynb to went_through_mine_worked\Mechanics 1 - Problem 6.ipynb
File copied from ./testing_vaild_code\pandas_basic_series.ipynb to went_through_mine_worked\pandas_basic_series.ipynb
File copied from ./testing_vaild_code\polynomial.ipynb to went_through_mine_worked\polynomial.ipynb
File copied from ./testing_vaild_code\Programs.ipynb to went_through_mine_worked\Programs.ipynb
File copied from ./testing_vaild_code\python', '1228.ipynb to went_through_mine_worked\python', '1228.ipynb
File copied from ./testing_vaild_code\python', 'chapter3(2).ipynb to went_through_mine_worked\python', 'chapter3(2).ipynb
File copied from ./testing_vaild_code\Python', 'Fizzbuzz.ipynb to went_through_mine_worked\Python', 'Fizzbuzz.ipynb
File copied from ./testing_vaild_code\python', 'unit 4 exercise.ipynb to went_through_mine_worked\python', 'unit 4 exercise.ipynb
File copied from ./testing_vaild_code\python-ml', '30. Scikit-learn tutorial 03 - Hyperparameter Search.ipynb to went_through_mine_worked\python-ml', '30. Scikit-learn tutorial 03 - Hyperparameter Search.ipynb
File copied from ./testing_vaild_code\Python_projects', 'server_log_regex.ipynb to went_through_mine_worked\Python_projects', 'server_log_regex.ipynb
File copied from ./testing_vaild_code\py_notes', 'Concatenate DataFrames.ipynb to went_through_mine_worked\py_notes', 'Concatenate DataFrames.ipynb
File copied from ./testing_vaild_code\qr-decomposition.ipynb to went_through_mine_worked\qr-decomposition.ipynb
File copied from ./testing_vaild_code\Regularization.ipynb to went_through_mine_worked\Regularization.ipynb
File copied from ./testing_vaild_code\RunLengthEncoding.ipynb to went_through_mine_worked\RunLengthEncoding.ipynb
File copied from ./testing_vaild_code\simple', 'Untitled5.ipynb to went_through_mine_worked\simple', 'Untitled5.ipynb
File copied from ./testing_vaild_code\testpython', 'homework3(1).ipynb to went_through_mine_worked\testpython', 'homework3(1).ipynb
File copied from ./testing_vaild_code\The Most Numbers.ipynb to went_through_mine_worked\The Most Numbers.ipynb
File copied from ./testing_vaild_code\Worse Design 2.ipynb to went_through_mine_worked\Worse Design 2.ipynb
